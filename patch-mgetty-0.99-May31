diff -u --recursive --new-file ../mgetty-0.99/voice/include/voice.h voice/include/voice.h
--- ../mgetty-0.99/voice/include/voice.h	Sat Feb  3 21:07:54 1996
+++ voice/include/voice.h	Mon Jun  3 23:17:51 1996
@@ -182,6 +182,7 @@
 #define US_ROBOTICS   (7)
 #define ZYXEL_1496    (8)
 #define ZYXEL_2864    (9)
+#define Linux         (10)
 
 /*
  * Special modem control characters
@@ -229,6 +230,7 @@
 extern int US_Robotics_handle_event _PROTO((int event, event_data data));
 extern int ZyXEL_1496_handle_event _PROTO((int event, event_data data));
 extern int ZyXEL_2864_handle_event _PROTO((int event, event_data data));
+extern int ISDN4Linux_handle_event _PROTO((int event, event_data data));
 
 /*
  * Voice modem answers
diff -u --recursive --new-file ../mgetty-0.99/voice/libpvf/zyxel.c voice/libpvf/zyxel.c
--- ../mgetty-0.99/voice/libpvf/zyxel.c	Sat Feb  3 21:07:56 1996
+++ voice/libpvf/zyxel.c	Mon Jun  3 23:17:51 1996
@@ -119,7 +119,8 @@
 
      if (read_rmd_hdr(&type, &nbits, &rom, in) != OK)
        return(FAIL);
-     if (strcmp(type, "ZyXEL 1496"))
+     if ((strcmp(type, "ZyXEL 1496")) &&
+         (strcmp(type, "ISDN4Linux"))   )
           {
           lprintf(L_ERROR, "%s: Wrong modem type found", program_name);
            return(FAIL);
diff -u --recursive --new-file ../mgetty-0.99/voice/libvoice/ISDN4Linux.c voice/libvoice/ISDN4Linux.c
--- ../mgetty-0.99/voice/libvoice/ISDN4Linux.c	Thu Jan  1 01:00:00 1970
+++ voice/libvoice/ISDN4Linux.c	Thu Jun  6 01:31:10 1996
@@ -0,0 +1,475 @@
+/* 
+ * ISDN4Linux.c
+ *
+ * This file contains the ISDN4Linux specific hardware stuff.
+ *
+ */
+
+#include "../include/voice.h"
+
+char *libvoice_ISDN4Linux_c = "$Id:$";
+
+/*
+ * Here we save the current mode of operation of the voice modem when
+ * switching to voice mode, so that we can restore it afterwards.
+ */
+
+static char mode_save[VOICE_BUF_LEN] = "";
+
+/*
+ * Internal status variables for aborting some voice modem actions.
+ */
+
+static int stop_dialing;
+static int stop_playing;
+static int abort_playing;
+static int stop_recording;
+static int stop_waiting;
+static int is_voicecall;
+
+/*
+ * ISDN4Linux samples with 8000 samples per second with a maximum of 8 bit
+ * per sample. We want to buffer voice data for 0.1 second, so we need a 
+ * buffer less or equal to 8000 * 0.1 = 800 bytes.
+ */
+
+#define ISDN4LINUX_BUFFER_SIZE 800
+static int isdn4linux_buffer_size = ISDN4LINUX_BUFFER_SIZE;
+
+/*
+ * This function handles the <DLE> shielded codes.
+ */
+
+#define ST_NO_INPUT (0x00)
+#define ST_GOT_DLE  (0x01)
+
+static int modem_answer_state = ST_NO_INPUT;
+
+static void handle_modem_answer(char new_byte)
+{
+  lprintf(L_JUNK, "%s: Got character from ISDN %02x, state %02x",
+	  program_name, new_byte, modem_answer_state);
+        
+  switch (modem_answer_state) {
+    case ST_NO_INPUT:
+      switch (new_byte) {
+	case DLE:
+	  modem_answer_state = ST_GOT_DLE;
+	  break;
+	case XON:
+	  lprintf(L_WARN, "%s: Received XON",
+		  program_name);
+	  break;
+	case XOFF:
+	  lprintf(L_WARN, "%s: Received XOFF",
+		  program_name);
+	  break;
+	case NL:
+	case CR:
+	  break;
+	default:
+	  lprintf(L_ERROR, "%s: Illegal ISDN answer 0x%2x",
+		  program_name, new_byte);
+      }  
+      return;
+    case ST_GOT_DLE:
+      switch (new_byte) {
+	case DC4:
+	  stop_playing = TRUE;
+	  abort_playing = TRUE;
+	  voice_handle_event(SIGNAL_SIGHUP, 0);
+          break;	  
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	case '*':
+	case '#':
+	case 'A':
+	case 'B':
+	case 'C':
+	case 'D':
+	  voice_handle_event(RECEIVED_DTMF, new_byte);
+	  break;
+	case 'b':
+	  voice_handle_event(BUSY_TONE, 0);
+	  break;
+	case 'c':
+	  voice_handle_event(FAX_CALLING_TONE, 0);
+	  break;
+	case 'd':
+	  voice_handle_event(DIAL_TONE, 0);
+	  break;
+	case 'e':
+	  voice_handle_event(DATA_CALLING_TONE, 0);
+	  break;
+	case 'q':
+	  voice_handle_event(SILENCE_DETECTED, 0);
+	  break;
+	case 's':
+	  voice_handle_event(NO_VOICE_ENERGY, 0);
+	  break;
+	default:
+	  lprintf(L_ERROR,
+		  "%s: Illegal <DLE> shielded code 0x%x", 
+		  program_name, new_byte);
+      }
+      modem_answer_state = ST_NO_INPUT;
+      return;
+  }
+  
+}
+
+/*
+ * This is the main handle event routine for the ISDN4Linux.
+ */
+
+int ISDN4Linux_handle_event(int event, event_data data)
+{
+  int i;
+  int bytes_in;
+  int bytes_out;
+  int bytes_written;
+  int result;
+  TIO tio_save;
+  TIO tio;
+  char buffer[VOICE_BUF_LEN];
+  char input_buffer[ISDN4LINUX_BUFFER_SIZE];
+  char output_buffer[2 * ISDN4LINUX_BUFFER_SIZE];
+  
+  switch (event) {
+    case VOICE_ANSWER_PHONE:
+      /* Check call-type:
+       * S20 = 1 -> voice call
+       * S20 = 4 -> data call
+       */
+      result = voice_command("ATS20?", "0|1|2|3|4");
+      is_voicecall = (result==VMA_USER_2);
+      if (is_voicecall)
+        return(voice_command("ATA","VCON"));
+      return(OK);
+    case VOICE_BEEP:
+#ifdef ISDN_FUTURE
+      sprintf(buffer, "AT+VTS=[%d,0,%d]", data.beep.frequency, 
+	      data.beep.length);
+      if (voice_command(buffer, "OK") != VMA_USER_1)
+	return(ERROR);      
+#endif
+      return(OK);
+    case VOICE_DIAL:
+	is_voicecall = 0;
+	result = ERROR;
+	voice_modem_state = DIALING;
+	stop_dialing = FALSE;
+	sprintf(buffer, "ATD%s", (char*) data.p);                        
+	if (voice_command(buffer, "") != OK)
+	  return(ERROR);                      
+	while (!stop_dialing) {
+	  voice_read(buffer);
+	  result = voice_analyze(buffer, NULL);
+	  switch (result) {
+	    case VMA_BUSY:
+	    case VMA_FAIL:
+	    case VMA_ERROR:
+	    case VMA_NO_ANSWER:
+	    case VMA_NO_CARRIER:
+	    case VMA_NO_DIAL_TONE:
+	      stop_dialing = TRUE;
+	      result = ERROR;
+	      break;
+	    case VMA_VCON:
+	      stop_dialing = TRUE;
+	      is_voicecall = 1;
+	      result = OK;
+	      break;
+	  }               
+	}
+	voice_modem_state = IDLE;
+	return(result);
+    case VOICE_INIT:
+      lprintf(L_MESG, "initializing ISDN4Linux voice mode");
+      voice_modem_state = INITIALIZING;
+#if ISDN_FUTURE
+      /*
+       * ATS40.3=1 - Enable distincitve ring type 1 (RING)
+       * ATS40.4=1 - Enable distincitve ring type 2 (RING 1)
+       * ATS40.5=1 - Enable distincitve ring type 3 (RING 2)
+       * ATS40.6=1 - Enable distincitve ring type 4 (RING 3)
+       */
+      
+      /*
+       * AT+VSD=x,y - Set silence threshold and duration.
+       */
+      sprintf(buffer, "AT+VSD=%d,%d",
+	      cvd.rec_silence_threshold.d.i * 31 / 100, 
+	      cvd.rec_silence_len.d.i);
+      if (voice_command(buffer, "OK") != VMA_USER_1)
+	lprintf(L_WARN,
+		"setting recording preferences didn't work");
+#endif /* ISDN_FUTURE */
+      voice_modem_state = IDLE;
+      return(OK);
+    case VOICE_MESSAGE_LIGHT_OFF:
+      return(OK);
+    case VOICE_MESSAGE_LIGHT_ON:
+      return(OK);
+    case VOICE_MODE_OFF:
+      sprintf(buffer, "AT+FCLASS=%s", mode_save);
+      voice_command(buffer, "OK");
+      return(OK);
+    case VOICE_MODE_ON:
+      voice_command("AT+FCLASS?", "");
+      voice_read(mode_save);
+      voice_flush(1);
+      voice_command("AT+FCLASS=8", "OK");
+      return(OK);
+    case VOICE_PLAY_FILE:
+      stop_playing = FALSE;
+      abort_playing = FALSE;
+      modem_answer_state = ST_NO_INPUT;
+      voice_modem_state = PLAYING;
+      if (!is_voicecall) {
+	voice_handle_event(DATA_CALLING_TONE, 0);
+	return(OK);
+      }
+      tio_get(voice_fd, &tio);
+      tio_save = tio;
+      
+      tio_set_flow_control(voice_fd, &tio, FLOW_HARD);
+      tio_set(voice_fd, &tio);
+      voice_command("AT+VTX", "CONNECT");
+     
+      while (!stop_playing) {
+	if ((bytes_in = read(data.i, input_buffer,
+			     isdn4linux_buffer_size)) <= 0)
+	  break;
+
+	bytes_out = 0;
+	for (i = 0; i < bytes_in; i++) {
+	  output_buffer[bytes_out] = input_buffer[i];
+	  if (output_buffer[bytes_out++] == DLE)
+	    output_buffer[bytes_out++] = DLE;
+	}
+	lprintf(L_JUNK, "%s: <DATA %d bytes>", program_name,
+		bytes_out);
+	
+	errno = 0;
+	bytes_written = 0;
+                                
+	while (((bytes_written +=
+		 write(voice_fd,
+		       &output_buffer[bytes_written], bytes_out - 
+		       bytes_written)) != bytes_out) && (errno == 0))
+	  ;
+
+	if (bytes_written != bytes_out)
+	  lprintf(L_ERROR, 
+		  "%s: could only write %d bytes of %d bytes (errno 0x%x)", 
+		  program_name, bytes_written, bytes_out, errno);
+                         
+	while (check_for_input(voice_fd)) {
+	  char modem_byte;
+	  
+	  if (read(voice_fd, &modem_byte, 1) != 1)
+	    lprintf(L_ERROR, 
+		    "%s: could not read byte from ISDN", 
+		    program_name);
+	  else
+	    handle_modem_answer(modem_byte);
+	  
+	}
+	
+      }
+      if (!abort_playing) {
+        sprintf(output_buffer, "%c%c", DLE, ETX);
+        lprintf(L_JUNK, "%s: <DLE><ETX>", program_name);
+        write(voice_fd, output_buffer, strlen(output_buffer));
+        tio_set(voice_fd, &tio_save);
+        voice_command("", "VCON");
+        voice_command("AT", "OK");
+      } else {
+        lprintf(L_JUNK, "%s: got abort sequence", program_name);
+        voice_command("\rAT", "OK");
+      }
+      voice_modem_state = IDLE;
+      if (stop_playing)
+	return(INTERRUPTED);
+      return(OK);
+    case VOICE_RECORD_FILE:
+      {
+	int got_DLE_ETX = FALSE;
+	int was_DLE     = FALSE;
+                                
+	stop_recording = FALSE;
+	modem_answer_state = ST_NO_INPUT;
+	voice_modem_state = RECORDING;
+        if (!is_voicecall) {
+  	  voice_handle_event(DATA_CALLING_TONE, 0);
+	  return(OK);
+        }
+
+	tio_get(voice_fd, &tio);
+	tio_save = tio;
+	tio_set_flow_control(voice_fd, &tio, FLOW_HARD);
+	tio.c_cc[VMIN] = (isdn4linux_buffer_size > 0xff) ? 0xff :
+	  isdn4linux_buffer_size;
+	tio.c_cc[VTIME] = 1;
+	tio_set(voice_fd, &tio);
+
+	voice_command("AT+VRX", "CONNECT");
+	
+	i = 0;
+	bytes_in = 0;
+	while (!got_DLE_ETX) {
+	  if ((bytes_in = read(voice_fd, input_buffer,
+			       isdn4linux_buffer_size)) <= 0) {
+	    lprintf(L_ERROR, 
+		    "%s: could not read byte from ISDN", 
+		    program_name);
+	    return(FAIL);
+	  }
+	  bytes_out = 0;
+	  for (i = 0; (i < bytes_in) && !got_DLE_ETX; i++) {
+	    if (was_DLE) {
+	      was_DLE = FALSE;
+	      switch (input_buffer[i]) {
+		case DLE:
+		  output_buffer[bytes_out++] = DLE;
+		  break;
+		case ETX:
+		  got_DLE_ETX = TRUE;
+		  lprintf(L_JUNK, "%s: <DATA %d bytes>",
+			  voice_modem_name, bytes_out);
+		  lprintf(L_JUNK, "%s: <DLE><ETX>",
+			  voice_modem_name);
+		  break;
+		default:
+		  handle_modem_answer(DLE);
+		  handle_modem_answer(input_buffer[i]);
+	      }
+	    } else {
+	      if (input_buffer[i] == DLE)
+		was_DLE = TRUE;
+	      else
+		output_buffer[bytes_out++] =
+		  input_buffer[i];
+	    }
+	    
+	  }
+	  write(data.i, output_buffer, bytes_out);
+	  if (!got_DLE_ETX)
+	    lprintf(L_JUNK, "%s: <DATA %d bytes>",
+		    voice_modem_name, bytes_out);
+	}
+	tio_set(voice_fd, &tio_save);
+	if (voice_analyze(&input_buffer[i], "\r\nVCON") == VMA_USER_1)
+	  lprintf(L_JUNK, "%s: VCON", voice_modem_name);
+	else {
+	  int j;
+	  
+	  lprintf(L_JUNK, "%s: data left in buffer: ",
+		  voice_modem_name);
+	  for (j = i; j < bytes_in ; j++)
+	    lputc(L_JUNK, input_buffer[j]);
+	  voice_command("AT", "OK");
+	}
+	voice_command("AT", "OK");
+	voice_modem_state = IDLE;
+	return(OK);
+      }
+    case VOICE_SET_COMPRESSION:
+      switch (data.i) {
+	case 2:
+	  isdn4linux_buffer_size =
+	    ISDN4LINUX_BUFFER_SIZE * 2 / 4;
+	  voice_command("AT+VSM=2", "OK");
+	  return(OK);
+	case 3:
+	  isdn4linux_buffer_size =
+	    ISDN4LINUX_BUFFER_SIZE * 3 / 4;
+	  voice_command("AT+VSM=3", "OK");
+	  return(OK);
+	case 4:
+	  isdn4linux_buffer_size =
+	    ISDN4LINUX_BUFFER_SIZE * 4 / 4;
+	  voice_command("AT+VSM=4", "OK");
+	  return(OK);
+	case 5:
+	case 6:
+	case 7:
+	  isdn4linux_buffer_size =
+	    ISDN4LINUX_BUFFER_SIZE * 8 / 4;
+          sprintf(buffer,"AT+VSM=%d",data.i);
+	  voice_command(buffer, "OK");
+	  return(OK);
+      }
+      lprintf(L_WARN, 
+	      "ISDN4Linux handle event: Illegal voice compression method (%d)", 
+	      data.i);
+      return(FAIL);
+    case VOICE_SET_DEVICE:
+      switch (data.i) {
+	case NO_DEVICE:
+	  voice_write("AT+VLS=0");
+	  
+	  if (voice_command("", "AT+VLS=0|OK") == VMA_USER_1)
+	    voice_command("", "OK");
+	  
+	  return(OK);
+	case DIALUP_LINE:
+	  voice_command("AT+VLS=2", "VCON");
+	  return(OK);
+      }
+      lprintf(L_WARN, 
+	      "ISDN4Linux handle event: Unknown output device (%d)", 
+	      data.i);
+      return(FAIL);
+    case VOICE_STOP_DIALING:
+      stop_dialing = TRUE;
+      return(OK);
+    case VOICE_STOP_PLAYING:
+      stop_playing = TRUE;
+      return(OK);
+    case VOICE_STOP_RECORDING:
+      stop_recording = TRUE;
+      voice_write("AT");
+      return(OK);
+    case VOICE_STOP_WAITING:
+      stop_waiting = TRUE;
+      return(OK);
+    case VOICE_WAIT:
+      stop_waiting = FALSE;
+      modem_answer_state = ST_NO_INPUT;
+      voice_modem_state = WAITING;
+      alarm(data.i);
+      
+      while (!stop_waiting) {
+	while (check_for_input(voice_fd)) {
+	  char modem_byte;
+	  
+	  if (read(voice_fd, &modem_byte, 1) != 1)
+	    lprintf(L_ERROR, 
+		    "%s: could not read byte from ISDN", 
+		    program_name);
+	  else
+	    handle_modem_answer(modem_byte);
+	  
+	}
+	
+	delay(100);
+      }
+      
+      voice_modem_state = IDLE;
+      alarm(0);
+      return(OK);
+  }
+  
+  lprintf(L_WARN, "ISDN4Linux handle event: Unknown event %04x", event);
+  return(FAIL);
+}
diff -u --recursive --new-file ../mgetty-0.99/voice/libvoice/Makefile voice/libvoice/Makefile
--- ../mgetty-0.99/voice/libvoice/Makefile	Sat Feb  3 21:06:15 1996
+++ voice/libvoice/Makefile	Mon Jun  3 23:17:51 1996
@@ -9,7 +9,7 @@
 VOICEOBJS=analyze.o beep.o close.o command.o detect.o event.o flush.o \
 	init.o mode.o open.o play.o read.o record.o shell.o signal.o write.o \
 	Cirrus_Logic.o Dolphin.o Elsa.o Rockwell.o Sierra.o UMC.o \
-	US_Robotics.o ZyXEL_1496.o ZyXEL_2864.o
+	US_Robotics.o ZyXEL_1496.o ZyXEL_2864.o ISDN4Linux.o
 
 .c.o:
 	$(CC) $(CFLAGS) -c $*.c
diff -u --recursive --new-file ../mgetty-0.99/voice/libvoice/detect.c voice/libvoice/detect.c
--- ../mgetty-0.99/voice/libvoice/detect.c	Sat Feb  3 21:08:02 1996
+++ voice/libvoice/detect.c	Mon Jun  3 23:17:51 1996
@@ -48,7 +48,7 @@
       */
 
      switch (voice_command("ATI",
-      "OK|282|1443|1445|1496|2864|2886|14400|1.04|144"))
+      "OK|282|1443|1445|1496|2864|2886|14400|1.04|144|Linux"))
           {
           case VMA_USER_1:
                break;
@@ -180,6 +180,20 @@
                     lprintf(L_MESG, "Creatix PhoneMaster 144VFi detected");
                     return(OK);
                     };
+
+          case VMA_USER_11:
+
+               /*
+                * It's an ISDN4Linux virtual modem emulator,
+                */
+
+               voice_flush(1);
+               voice_modem = Linux;
+               voice_modem_name = "Linux ISDN Subsystem";
+               voice_modem_handle_event = ISDN4Linux_handle_event;
+               voice_modem_type = "ISDN4Linux";
+               lprintf(L_MESG, "Linux ISDN Subsystem detected");
+               return(OK);
 
           };
 
